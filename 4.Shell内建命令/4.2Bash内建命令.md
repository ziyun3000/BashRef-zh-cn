## 4.2 Bash内建命令（Bash Builtin Commands）

这一节所描述的是Bash中独有的，或经过扩展的内建命令。其中有一些命令是定义在POSIX标准中的。

### alias

<p style="background-color: black">
alias [-p] [<i>name</i>[=<i>value</i>] ...]
</p>

如果“alias”命令不带有任何参数或使用了“-p”选项，则将别名列表表示为可用于再次输入的格式输出到标准输出中。如果提供了参数，则为每个给出“value”值的“name”进行别名定义。如果没有给出“value”，则打印出该别名的名称和值。关于别名的描述，请参考6.6节《别名》。

### bind

<p style="background-color: black">
bind [-m <i>keymap</i>] [-lpsvPSVX]
bind [-m <i>keymap</i>] [-q <i>function</i>] [-u <i>function</i>] [-r <i>keyseq</i>]
bind [-m <i>keymap</i>] -f <i>filename</i>
bind [-m <i>keymap</i>] -x <i>keyseq:shell-command</i>
bind [-m <i>keymap</i>] <i>keyseq:function-name</i>
bind [-m <i>keymap</i>] <i>keyseq:readline-command</i>
</p>

显示当前读取行（Readline）的键和函数的绑定，或将读取行函数或宏与一个键序列绑定，或设置一个读取行变量。每一个非选项参数是一个命令，其可以出现在读取行初始化文件（参见8.3《Readline初始化文件》）中。但每一个绑定或命令必须作为一个分开的参数进行传递；例如，“"\C-x\C-r":re-read-init-file”。

如果下列选项出现，则具有如下含义：

选项 | 含义
--- | ---
-m *keymap* | 使用“*keymap*”在后继绑定中作为映射键产生作用。可接受的“keymap”名称有：“emacs”、“emacs-standard”、“emacs-meta”、“emacs-ctlx”、“vi”、“vi-move”、“vi-command”和“vi-insert”。“vi”等同于“vi-command”（“vi-move”也是一个意思）；“emacs”等同于“emacs-standard”。
-l | 列出所有读取行函数的名称。
-p | 显示为可用于输入或在读取行初始化文件中使用的读取行函数名称和绑定。
-P | 列出当前读取行函数名称和绑定。
-v | 显示为可用于输入或在读取行初始化文件中使用的读取行变量名称和绑定。
-V | 列出当前读取行变量名称和值。
-s | 显示输出为可用于输入或在读取行初始化文件中使用的，绑定到宏的读取行键序列和字符串。
-S | 显示输出绑定到宏的读取行键序列和字符串。
-f *filename* | 从“*filename*”中读取绑定键。
-q *function* | 查询哪个键调用了这个函数。
-u *function* | 解除这个函数的所有绑定的键。
-r *keyseq* | 移除“*keyseq*”的任何当前绑定。
-x *keyseq*:*shell-command* | 在任何时候输入“*keyseq*”都会执行“*shell-command*”。当“*shell-command*”执行时，shell会将读取行的行缓冲内容设置到变量“READLINE_LINE”中，并且变量“READLIN_POINT”和“READLINE_MARK”会分别设置为插入点的当前位置和保存的插入点（标记位）。如果执行的命令改变了“READLINE_LINE”、“READLINE_POINT”或“READLINE_MARK”的任何一个值，则新值会反应到编辑状态中。
-X | 以可以作为重新输入的格式列出所有绑定到shell命令的键序列和这些关联的命令。

返回状态是零，除非提供了一个无效的选项或出现了一个错误。

### builtin

<p style="background-color: black">
builtin [<i>shell-builtin</i> [<i>args</i>]]
</p>

运行一个shell内建命令，并将参数“*args*”传入，最后返回该命令的退出状态。在定义一个与shell内建命令重名的函数时，在该函数中保留内建命令的功能时，该命令非常有用。如果“*shell-builtin*”不是一个内建命令时，会返回非零状态。

### caller

<p style="background-color: black">caller [<i>expr</i>]</p>

返回任意活动的子程序调用（一个shell函数或一个使用“.”或“source”内建命令执行的脚本）的上下文。

不加参数“expr”时，“caller”显示当前子程序调用的行号和源文件名。如果提供的“expr”是一个非负整数，则caller显示的是当前执行调用堆栈中相对位置的行号、子程序名称和源文件。这个额外的信息是有用的，例如打印堆栈追踪。当前frame是“frame 0”。

返回状态值为零，除非shell没有执行一个子程序调用或“expr”没有对应到调用堆栈中的一个有效位置。

### command

<p style="background-color: black">command [-pVv] <i>command</i> [<i>arguments ...</i>]</p>

运行带有“*arguments*”参数的“*command*”命令，忽略任何和参数“*command*”相同名称的函数。只执行shell内建命令或在PATH变量中搜索到的命令。如果有一个shell函数，其名称是ls，在函数中运行“command ls”就会执行外部命令ls，而不是递归调用该函数。“-p”选项的含义是使用变量PATH为默认值，用于确保可找到所有的标准命令工具。如果找不到要运行的命令或出现了一个错误，则返回状态值为127，否则返回命令“*command*”的退出状态。

如果提供了“-V”或“-v”选项，则打印命令“*command*”的描述。“-v”选项使用单一单词来表示调用“*command*”的命令名或文件名；“-V”选项则产生更多的说明。在这种情况下，如果找到命令则返回状态零，否则返回非零。

### declare

<p style="background-color: black">declare [-aAfFgiIlnrtux] [-p] [<i>name</i>[<i>=value</i>] ...]</p>

声明变量并给其设置属性。如果没有给出变量名，则显示所有变量的值。

“-p”选项用于显示每个“*name*”所代表的变量的值和属性。当使用“-p”选项时还带有“*name*”参数，其它附加选项除了“-f”和“-F”之外，都会被忽略。

当出现“-p”选项并且未给出“*name*”参数时，“declare”将会显示带有由其它选项指定的属性的所有变量的属性和变量值。如果在使用“-p”时没有其它选项出现，则“declare”显示所有变量的属性和值。“-f”选项用于只显示shell函数。

“-F”选项不会显示函数定义，仅显示函数名和属性。如果使用“shopt”命令开启了shell选项“extdebug”，将显示每个“*name*”的定义所在的源文件名和所在行数。

即使当“declare”执行在shell函数内部，“-g”选项也会在全局作用域强制创建或修改变量。但在其它情况下，该选项会被忽略。

“-I”选项会使本地变量继承自附近作用或中具有相同“*name*”名的现有变量的属性（“nameref”属性除外）和值。如果没有现有变量存在，本地变量在初始时重置。

下列选项常用于对带有指定属性的变量进行限制输出或给出变量属性：

选项 | 说明
--- | ---
-a | 每一个“*name*”为一个索引数组变量。
-A | 每一个“*name*”为一个关联数组变量。
-f | 只用于函数名。
-i | 视变量为一个整数类型；当变量赋值时进行算术运算。
-l | 当变量进行赋值时，所有大写字母都改写为小写字母。禁用大写属性。
-n | 给予每一个“*name*”变量“nameref”属性，使其成为名称引用并参考到另外一个其它变量上。由“name”的值来定义那个其它变量。对于“*name*”的所有引用、赋值和属性修改，除了使用或改变“-n”属性其本身外，都将应用于“*name*”值所参考到的变量身上。“nameref”属性不能应用到数组变量上。
-r | 设置“*name*”变量为只读。这些只读变量在后继赋值语句中不能进行赋值操作或进行释放操作。
-t | 对每一个“*name*”变量设置“trace”属性。追踪函数从调用方shell继承DEBUG和RETURN捕获器。“trace”属性对于变量来说没有特殊意义。
-u | 当变量赋值时，将所有小写字母都改写为大写字母。禁用小写属性。
-x | 通过环境将每一个“*name*”导出给后继命令。

使用加号“+”替换选项前面的减号“-”来关闭属性。但例外是“+a”和“+A”不能用于摧毁数组变量，“+r”不能用于移除只读属性。在函数中使用“declare”时，其会将每个“*name*”变量本地化，就像使用了“local”命令一样，但使用“-g”选项时除外。如果一个变量名后跟随着“=*value*”，则该变量的值将设置为“*value*”。

当使用“-a”或“-A”和复合赋值语法来创建数组变量时，直到后继赋值发生时附加属性才会生效。

返回状态为零，除非下列情况发生：

- 试图使用“-f foo=bar”形式定义一个函数。
- 试图对只读变量进行赋值。
- 试图在不使用复合赋值语法情况下对数组变量进行赋值（参见6.7《数组》）。
- 变量名“*name*”不是一个有效的shell变量名。
- 试图关闭只读变量的只读属性。
- 试图关闭数组变量的数组属性。
- 试图使用“-f”选项显示一个不存在的函数。

### echo

<p style="background-color: black">echo [-neE] [<i>arg</i> ...]</p>

使用空格作为分隔符和使用换行作为终止符来输出参数“*arg*”。返回状态为零，除非出现一个写错误。如果指定了“-n”，则抑制尾部的换行。如果给出“-e”选项，则开启反斜线转义字符解释器。“-E”选项则是关闭反斜线转义字符解释器，即使系统默认对其转义。shell选项“xpg_echo”默认可以用来动态确定echo是否对转义字符进行转义扩展。“echo”不会将“--”解释为选项结束。

下列是“echo”解释转义列表：

转义符 | 含义
--- | ---
\a | 报警（铃声）
\b | 向前删除
\c | 抑制进一步的输出
\e<br>\E | 取消
\f | 换页
\n | 换行
\r | 回车
\t | 水平制表符
\v | 垂直制表符
\\ | 反斜线
\0*nnn* | 八进制值*nnn*（0到3位）表示一个8位字符
\x*HH* | 十六进制值*HH*（1到2位）表示一个8位字符
\u*HHHH* | 十六进制值*HHHH*（1到4位）表示一个Unicode(ISO/IEC 10646)字符
\U*HHHHHHHH* | 十六进制值*HHHHHHHH*（1到8位）表示一个Unicode(ISO/IEC 10646)字符

### enable

<p style="background-color: black">enable [-a] [-dnps] [-f <i>filename</i>] [<i>name</i> ...]</p>

用于开启或禁用shell内建命令。禁用一个内建命令可以使一个与该内建命令同名的外部命令直接执行，而不用指定完整路径，即使shell通常情况下在搜索外部命令前先对内建命令进行搜索。如果使用了“-n”选项，则禁用“*name*”参数所代表的内建命令。否则，则是开启该内建命令。例如，要直接使用一个在“$PATH”中叫test的外部命令而不是shell的内建命令test时，先键入“enable -n test”来禁用内建命令。

如果“-p”选项出现，或没有给出name参数，则打印shell内建命令列表。不带有其它参数时，列表所包含的是所有开启的shell内建命令。“-a”选项意味着列出的内建命令列表具有指示该命令是处于开启还是关闭状态。

在支持动态加载的系统中，“-f”选项意味着从共享对象filename中加载新内建命令。“-d”选项会删除使用“-f”选项加载进来的内建命令。

如果没有选项出现，则显示一个shell内建命令列表。“-s”选项只显示POSIX特定的内建命令。如果在使用“-s”的同时加入“-f”，则新加载的内建命令就变为特定内建命令。

返回状态为零，除非“*name*”不是一个shell内建命令或从共享对象中加载新内建命令时出错。

### help

<p style="background-color: black">help [-dms] [<i>pattern</i>]</p>

显示关于内建命令的帮助信息。如果指定了“*pattern*”，“help”则给出所有匹配“*pattern*”的命令的详细帮助。否则将打印内建命令列表。

如果出现选项，则具有以下含义：

选项 | 含义
--- | ---
-d | 显示每一个“*pattern*”的短描述。
-m | 使用类似man page格式显示每一个“*pattern*”的描述。
-s | 只显示每一个“*pattern*”的简短概要语法。

返回状态为零，除非“*pattern*”没有匹配到任何命令。

### let

<p style="background-color: black">let <i>expression</i> [<i>expression</i> ...]</p>

内建命令“let”允许在shell变量上执行算术运算。每一个表达式“*expression*”可以依据下面6.5节《Shell算术运算》中的规则进行表达式运算。如果最后一个表达式运算结果为0，则“let”返回1；否则返回0。

### local

<p style="background-color: black">local [<i>option</i>] <i>name</i>[=<i>value</i>] ...</p>

对于命令中的每一个参数，会创建以“*name*”命名的本地变量，并将“value”赋值给它。“declare”命令的所有选项是该命令可接受的选项。“local”只能用于函数内部；它将变量“*name*”的作用域设置为在该函数和其子函数中可见。如果“*name*”是“-”，则shell选项集合只作用于调用“local”命令的函数内部：在函数内部使用“set”内建命令所改变的shell选项，会在函数返回时将其还原到初始值。还原操作所产生的作用就像使用“set”命令将选项值设置为函数调用之前的状态一样。返回状态为零，除非在函数外部使用了“local”命令，或提供了一个无效的“*name*”，或“*name*”是一个只读变量。

### logout

<p style="background-color: black">logout [<i>n</i>]</p>

退出已登录的shell，向shell的父进程返回状态“*n*”。

### mapfile

<p style="background-color: black">mapfile [-d <i>delim</i>] [-n <i>count</i>] [-O <i>origin</i>] [-s <i>count</i>] [-t] [-u <i>fd</i>] [-C <i>callback</i>] [-c <i>quantum</i>] [<i>array</i>]</p>

从标准输入读取多行并存入索引数组变量“*array*”中。如果提供了“-u”选项，则从文件描述符“*fd*”中读取。变量MAPFILE是默认的数组“*array*”。如果提供了选项，则具有下列含义：

选项 | 含义
--- | ---
-d | 使用“*delim*”的第一个字符代替换行来表示每一输入行的结束。如果“*delim*”是空字符串，“mapfile”在读到字符NUL时才结束行读取。
-n | 复制至多“*count*”行。如果“*count*”是0，则复制所有行。
-O | 从数组“*array*”的索引位置“*orgin*”开始进行赋值。默认索引位置为0。
-s | 丢弃前“*count*”行的读取。
-t | 从每一行读取中移除尾部的分隔符“*delim*”（默认是换行）。
-u | 从文件描述符“*fd*”中读取行，而不是从标准输入读取。
-C | 在每一次读取“*quantum*”行时执行“*callback*”。使用“-c”选项指定“*quantum*”。
-c | 用于指定在每一次调用“*callback*”时读取的行数。

如果在指定了“-C”时未指定“-c”，则默认的配额“*quantum*”为5000。当执行“*callback*”时，其提供要分配的下一个数组元素的索引位置，并且将分配给那个元素的行作为附加参数。在行读取后，将其分配给数组元素之前运行“*callback*”。

如果没有明确给出“*origin*”位置，“mapfile”会在数组“*array*”赋值前将其清空。

“mapfile”返回成功状态，除非提供了一个无效的选项或选项参数，或数组是无效的或不可被赋值的，或数组不是索引数组。

### printf

<p style="background-color: black">printf [-v <i>var</i>] <i>format</i> [<i>arguments</i>]</p>

按照“*format*”的格式将格式化后的“*arguments*”写入到标准输出。“-v”选项会将要打印到标准输出的结果分配到变量“*var*”中。

“*format*”的格式是包含了三种对象类型的字符串：明文字符，可直接复制到标准输出；字符转义序列，转换后复制到标准输出；格式规范，每个规范都会打印后面的连续参数“*argument*”。

除了printf(1)中的标准格式，printf还会解释下列扩展：

扩展 | 说明
--- | ---
%b | 会使“printf”将相应“*argument*”里的反斜线转义序列使用与“echo -e”（参见4.2《Bash内建命令》）相同的方式对其进行转义扩展。
%q | 会使“printf”使用“*format*”设定的格式将“*argument*”输出并可重用于shell输入。
%(datefmt)T | 会使“printf”使用“strftime(3)”格式字符串“*datefmt*”格式化格式化输出日期时间字符串。相应的参数“*argument*”是一个代表从新纪元开始的秒数的整数。可用到两个特殊参数值：“-1”代表当前时间，“-2”代表调用shell时的时间。如果没有指定参数，则转换行为就像给出了“-1”一样。这是“printf”正常行为的一个例外。

“%b”、“%q”和“%T”可以在格式规范中指定字段的宽度和精度，并且扩展后的参数需要比原始值使用更多字节（或更宽的字段）来表示这一字段，通常所包含的字符要多于原始字符。

除了开头允许使用加号“+”或减号“-”，对于非字符串格式标识符的参数都被视为C语言常量。并且如果开头的字符是单引号或双引号，则后面跟随的字符值是ASCII值。

“*format*”参数按需求对所有“*arguments*”参数进行格式化。如果“*fromat*”需要的参数个数比“*arguments*”提供的个数要多的话，格式化规范行为就会为所需的额外参数提供适当的0值或空字符串。命令成功的返回值是零，失败为非零值。

### read

<p style="background-color: black">read [-ers] [-a <i>aname</i>] [-d <i>delim</i>] [-i <i>text</i>] [-n <i>nchars</i>] [-N <i>nchars</i>] [-p <i>prompt</i>] [-t <i>timeout</i>] [-u <i>fd</i>] [<i>name</i> ...]</p>

从标准输入或从“-u”选项提供的参数“*fd*”代表的文件描述符中读取一行。之后使用在3.5.7《单词分割》中描述的规则进行单词分割，并且将第一个单词分配给第一个“*name*”参数，将第二个单词分配给第二个“*name*”参数，以此例推。如果单词个数多于“*name*”个数，则多余的单词和其之间的分隔符都分配给最后一个“*name*”参数。如果单词个数少于“*name*”个数，则剩余“*name*”参数将被分配为空（empty）值。使用变量“IFS”中的字符将读取行中的单词分割，其分割规则是与shell用于扩展分割的一样（参见3.5.7《单词分割》）。可以使用反斜线“\”移除其后面一个字符的特殊含义和用于行的继续读取。

如果出现下列选项，则具有以下含义：

选项 | 含义
--- | ---
-a *aname* | 分割出的单词分配给索引数组变量“*aname*”，起始下标为0。在分配之前会将“*aname*”中的所有元素先删除。忽略其它“*name*”参数。
-d *delim* | “*delim*”的第一个字符用于替换换行作为输入行的终结符。如果“*delim*”是一个空字符串，“read”将读取到NUL字符时才会终结一行。
-e | Readline（参见第8章《命令行编辑》）用于获取行。Readline使用当前编辑设置（或使用默认设置，如果之前没有激活过行编辑），但使用Readline的默认文件名补全机制。
-i *text* | 如果Readline正在读取行，在编辑开始之前将“*text*”放入编辑缓冲中。
-n *nchars* | “read”在读取“*nchars*”个字符后直接返回退出，而不是等到一整行读取完成。但如果在分隔符出现之前的字符个数小于nchars，则分隔符生效。
-N *nchars* | 除非遇到EOF或“read”运行超时，其会在精确读取“*nchars*”个字符后返回退出，而不会等待整行输入完成。在输入行中出现的分隔符不会被特殊对待，并且直到读取了“*nchars*”个字符后“read”才会返回退出。读取的结果不会依据变量IFS中的字符进行单词分割，其目的在于将读取的字符精确地分配给变量（关于反斜线的例外，可参见下面的“-r”选项）。
-p *prompt* | 在读取输入之前，显示一个末尾不带有换行的输入提示。只有在输入是来自于终端时才会显示这个提示。
-r | 如果给出了这个选项，反斜线将不会作为转义字符使用。反斜线会作为这一行的一部分进行读取。通常，一个反斜线加换行不会作为行继续读取符。
-s | 静默模式。如果行输入来自于终端，读取的字符不会在终端上回显出来。
-t *timeout* | 如果在“*timeout*”指定的秒数里没有完成整行的读取（或没有读取到指定的字符个数），则会引起“read”读取超时并且返回失败状态。“*timeout*”可以设置为一个带有小数点的小数。这个选项只在输入是从终端、管道或其它特殊文件中读取时生效；当其从一个常规文件中读取时则不会产生作用。如果读取超时，“read”会将部分已输入的字符存入指定的变量“*name*”中去。如果“*timeout*”设置为0，“read”不会试图读取任何数据而立即返回退出。如果在指定的文件描述符上的输入是可用的，则出状态为零，否则返回非零值。如果“*timeout*”超时，则返回一个大于128的退出状态。
-u *fd* | 从文件描述符“*fd*”中读取输入。

如果没有给出“*name*”参数，不包含尾部分隔符的未做任何更改的读取行将分配给变量REPLY。正常退出状态为零，除非遭遇“end-of-file”，或“read”超时（在这种情况下返回值大于128），或变量赋值出错（例如对读取变量进行赋值），或在“-u”选项使用时给出了一个无效的文件描述符。

### readarray

<p style="background-color: black">
readarray [-d <i>delim</i>] [-n <i>count</i>] [-O <i>origin</i>] [-s <i>count</i>] [-t] [-u <i>fd</i>] [-C <i>callback</i>] [-c <i>quantum</i>] [<i>array</i>]
</p>

从标准输入读取行，或如果使用了“-u”选项则从文件描述符读取，之后存入索引数组变量“*array*”中。与“*mapfile*”命令相同。

### source

<p style="background-color: black">source <i>filename</i></p>

与Bourne Shell内建命令“.”相同。

### type

<p style="background-color: black">type [-afptP] [<i>name</i> ...]</p>

对于每一个给出的“*name*”参数，如果将其用做一个命令名，则对其进行解释说明。

如果使用了“-t”选项，“type”则打印“alias”、“function”、“builtin”、“file”或“keyword”其中的一个单词来表示该命令是一个别名、shell函数、shell内建命令、磁盘文件或是一个保留字。如果找不到“*name*”，则不会打印任何信息，并且返回失败状态。

如果使用了“-p”选项，“type”会返回“*name*”代表的可执行的磁盘文件名，或如果“*name*”在使用“-t”时返回的不是一个“file”类型，则什么都不返回。

“-P”选项对每一个“*name*”参数在PATH路径中进行强制搜索，即使该在使用“-t”时不会返回“file”类型。

如果一个命令已经被缓冲到哈希表中，“-p”和“-P”则打印这个哈希值，这并不需要该文件首先出现在“$PATH”中。

如果“-a”选项出现，“type”会将所有包含可执行的“*name*”文件位置返回。当且仅当同时没有“-p”选项出现，其还会列出别名和函数。

如果“-f”选项出现，“type”不会试图去寻找shell函数。

如果所有“*name*”参数都找到，则返回状态零。如果有一个没有找到，则返回非零。

### typeset

<p style="background-color: black">
typeset [-afFgrxilnrtux] [-p] [<i>name</i>[=<i>value</i>] ...]
</p>

“typeset”命令是用于兼容Korn shell。它与内建命令“declare”用法类似。

### ulimit

<p style="background-color: black">
ulimit [-HS] -a
ulimit [-HS] [-bcdefiklmnpqrstuvxPRT] [<i>limit</i>]
</p>

如果系统允许的话，“ulimit”可通过可用资源提供对shell启动的进程进行控制。如果给出下列选项，则具有下列含义：

选项 | 含义
--- | ---
-S | 变更并报告关联到资源的软限制。
-H | 变更并执行关联到资源的硬限制。
-a | 报告所有当前限制；不进行限制设置。
-b | 最大套接字缓冲大小。
-c | 创建的核心文件最大大小。
-d | 一个进程的数据段最大大小。
-e | 最大计划优先级（"nice"）。
-f | shell及其子shell的文件写入最大大小。
-i | 挂起信号的最大数量。
-k | 可分配的kqueues的最大数量。
-l | 可被锁定的内存最大大小。
-m | 最大驻留集大小（大多数系统不遵守这一限制）。
-n | 打开文件描述符的最大个数（大多数系统不允许设置这个值）。
-p | 管道缓冲大小。
-q | POSIX消息队列的最大字节数量。
-r | 最大实时计划优先级。
-s | 最大堆栈大小。
-t | 最大CPU时间占用秒数。
-u | 对于一个单用户的最大可用进程数量。
-v | shell的最大可用虚拟内存数量，有些系统中还包含其子shell的。
-x | 最大文件锁数量。
-P | 最大伪终端的数量。
-R | 在被阻止前实时进程可运行的最大时长，单位毫秒。
-T | 最大线程数。

如果给出“*limit*”参数，并且没有使用“-a”选项，则“*limit*”则是指定资源的新值。“*limit*”特殊值“hard”、“soft”和“unlimited”分别代表当前的硬限制、当前的软限制和没有限制。一旦设置了一个硬限制，其不能被非根用户进行增量设置；软限制最大可以增加到硬限制的值。否则，除非提供“-H”选项，则只打印所指定资源的软限制当前值。当指定了多于一个的资源，如果所提供的限制名称和单位正确，则打印在其值的前面。当在设置新限制时，如果“-H”和“-S”选项都没有出现，则对硬、软两种限制都进行设置。如果没有选项给出，则假定为使用了“-f”选项。所有的值是以1024字节为一个增量单位，除了“-t”是使用的秒为单位；“-R”是使用毫秒；“-p”是使用512字节块为单位；“-P”、“-T”、“-b”、“-k”、“-n”和“-u”则是没有设定增量单位；并且，当在POSIX模式中，“-c”和“-f”则是使用512字节作为增量单位。

正常返回状态为零，除非给出了一个无效选项或参数，或当设置新限制时出现了一个错误。

### unalias

<p style="background-color: black">
unalias [-a] [<i>name</i> ... ]
</p>

从别名列表中删除给出的每一个“*name*”参数所代表的别名。如果“-a”选项出现，则删除所有别名。在6.6《别名》一节有对别名的详细说明。