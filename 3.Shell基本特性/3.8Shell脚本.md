## 3.8 Shell脚本（Shell Scripts）

Shell脚本就是一个包含了若干shell命令的文本文件。当调用Bash即没有加“-c”也没有加“-s”选项时，其后跟随的第一个非选项参数是一个文件时，Bash会从文件中读取命令并执行，然后退出。这种操作模式创建一个非交互式的shell。shell首先会在当前目录搜索这个文件，如果没有找到，则在变量“$PATH”中查找。

当Bash运行一个shell脚本时，其会将特殊参数“0”设置为这个文件的文件名，而不是shell名。并且如果给出了后继的参数，则将位置参数设置为这些参数。如果没有提供附加的参数，则不对位置参数进行设置。

使用chmod命令开启执行位标记，将shell脚本设置为可执行的。当Bash在“`$PATH`”中搜索命令时找到了这样的文件，它将孵化出一个用于执行该脚本的子shell。换句话说，如果“filename”是可执行的shell脚本的话，则执行

`filename arguments`

等同于执行

`bash filename arguments`

这个子shell重新初始化其自身，所以产生的效果就像调用一个新shell来解释这个脚本。其不同的是由其父shell（参考4.1节《Bourne Shell内建命令》的hash》）记住的命令位置都保留给了子shell。

大多数的Unix版本将其归为操作系统执行命令机制的一部分。如果脚本的第一行由“#!”两个字符开头，则这行剩下的部分用于指定程序的解释器。并且依赖于操作系统，可以为解释器加入一个或多个可选的参数。因此，你可以在第一行指定使用Bash、awk、Perl或其它解释器，在脚本剩下的部分使用这种语言进行编写。

解释器的参数是由脚本文件第一行中的解释器名后的一个或多个可选参数，解释器后的脚本文件名，以及向脚本提供的剩余参数组成的。不同的系统有不同的方法将解释器行分隔为解释器名和参数集。Bash会在操作系统不能处理该动作时自己执行这个动作。注意，一些老版本的Unix会限制使用解释器名和单个参数的总长度最大不能超过32个字符。所以超过一个参数会使脚本的移植性变差。

Bash脚本经常使用“`#! /bin/bash`”开头（假设Bash被安装到了“`/bin`”路径下面），这样一来即使其执行在其它shell下，也可以确保使用Bash作为这个脚本的解释器。这有一种公用的方式，使用“env”命令来寻找“bash”命令，即使其被安装到了其它目录。“`#! /usr/bin/env bash`”将在“`$PATH`”中寻找第一个出现的bash命令。